<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How To Deploy Your Django App Using Docker | HedonHermDev</title><meta name=keywords content><meta name=description content="Getting your Django app on the internet is - pardon my language - a pain in the ass.
You need to daemonize your app with something like Supervisor, then you need to setup a production ready database, then you need to setup a web-server using the likes of Nginx or Apache. And when it&rsquo;s all done, you need to setup files and directories to collect and maintain logs from your app."><meta name=author content="Me"><link rel=canonical href=https://hedonhermdev.github.io/posts/django-on-docker/><meta name=google-site-verification content="XYZabc"><link href=https://hedonhermdev.github.io/assets/css/stylesheet.min.62447981861ad5bc7761e73be43801fe136a2aaaa8b7afd18ce582c358716848.css integrity="sha256-YkR5gYYa1bx3Yec75DgB/hNqKqqot6/RjOWCw1hxaEg=" rel="preload stylesheet" as=style><link rel=icon href=https://hedonhermdev.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://hedonhermdev.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hedonhermdev.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://hedonhermdev.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://hedonhermdev.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','G-DT32618Q01','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="How To Deploy Your Django App Using Docker"><meta property="og:description" content="Getting your Django app on the internet is - pardon my language - a pain in the ass.
You need to daemonize your app with something like Supervisor, then you need to setup a production ready database, then you need to setup a web-server using the likes of Nginx or Apache. And when it&rsquo;s all done, you need to setup files and directories to collect and maintain logs from your app."><meta property="og:type" content="article"><meta property="og:url" content="https://hedonhermdev.github.io/posts/django-on-docker/"><meta property="og:image" content="https://hedonhermdev.github.io/60"><meta property="article:published_time" content="2020-04-30T10:29:26+00:00"><meta property="article:modified_time" content="2020-04-30T10:29:26+00:00"><meta property="og:site_name" content="HedonHermDev"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hedonhermdev.github.io/60"><meta name=twitter:title content="How To Deploy Your Django App Using Docker"><meta name=twitter:description content="Getting your Django app on the internet is - pardon my language - a pain in the ass.
You need to daemonize your app with something like Supervisor, then you need to setup a production ready database, then you need to setup a web-server using the likes of Nginx or Apache. And when it&rsquo;s all done, you need to setup files and directories to collect and maintain logs from your app."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How To Deploy Your Django App Using Docker","name":"How To Deploy Your Django App Using Docker","description":"Getting your Django app on the internet is - pardon my language - a pain in the ass.\nYou need to daemonize your app with something like Supervisor, then you need to setup a …","keywords":[],"articleBody":"Getting your Django app on the internet is - pardon my language - a pain in the ass.\nYou need to daemonize your app with something like Supervisor, then you need to setup a production ready database, then you need to setup a web-server using the likes of Nginx or Apache. And when it’s all done, you need to setup files and directories to collect and maintain logs from your app.\nYou could do all that, or you could use Docker.\nHere’s what you’ll learn In this tutorial you’ll learn to deploy a Django app with Docker and docker-compose. By the end of the tutorial, you’ll have a single command that you can use with *any *Django app to deploy it to a server.\nThe prerequisites To complete this tutorial, you will need:\n Familiarity with using the command line. Familiarity with Python virtual environments. We will use a virtual environment to isolate the dependencies of our project. To install the python virtual environment module use: pip install virtualenv. A basic understanding of YAML files.  Step 0 — Installing Dependencies To follow this tutorial, you will need both Docker and Docker-Compose on your machine. Follow the steps below depending on your operating system.\nInstalling on Ubuntu You can install Docker Engine on your system by using the convenience script provided by Docker.\n$ curl -fsSL https://get.docker.com -o get-docker.sh $ sudo sh get-docker.sh To install Docker-Compose, first download the binaries from the Github repo. Then apply executable permissions to the binary.\n$ sudo curl -L \"https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose $ sudo chmod +x /usr/local/bin/docker-compose Installing on a Mac Docker Desktop for Mac already includes Docker-Compose. To install Docker Desktop on Mac, download the package from here and run the installer.\nNote: If the above steps don’t work for you, you can go to this link and find more information depending on your operating system.\nStep 1 — Setting Up The Django Project For following along, you can make a sample Django project or follow the steps with your existing project. I suggest making a sample app and then implementing it on your existing project so that you can tweak things to suit your purpose.\nCreate a new virtual environment.\n$ mkdir deployment-project \u0026\u0026 cd deployment-project $ virtualenv venv $ source venv/bin/activate Install Django and make a new Django project.\n$ pip install django $ django-admin startproject djangoproject List out the requirements in a requirements.txt file.\n$ pip freeze  djangoproject/requirements.txt In the djangoproject/settings.py file, change the ALLOWED_HOSTS to the following:\nALLOWED_HOSTS = [\"localhost\", \"127.0.0.1\", \"0.0.0.0\"] Doing this allows us to access the Django app from outside the container.\nStep 1 — Writing The Dockerfile The first step to containerising our Django app is making a Dockerfile. In the djangoproject directory, make a new file named Dockerfile and put the following in it:\n# Use the official Python image from the Docker HubFROMpython:3.8.2# These two environment variables prevent __pycache__/ files.ENV PYTHONUNBUFFERED 1ENV PYTHONDONTWRITEBYTECODE 1# Make a new directory to put our code in.RUN mkdir /code# Change the working directory. # Every command after this will be run from the /code directory.WORKDIR/code# Copy the requirements.txt file.COPY ./requirements.txt /code/# Upgrade pipRUN pip install --upgrade pip# Install the requirements.RUN pip install -r requirements.txt# Copy the rest of the code. COPY . /code/This Dockerfile is used to build the container for your Django app. Each line is a step of the build. We will make a lot of changes in this, but for now, it works.\n Why you should copy the requirements.txt file before copying the code While building the container, Docker caches stages of the build. So if you change your code but the requirements.txt file is the same, Docker doesn’t have to install all the requirements again for building the container.\n Step 2 — Writing the Docker-Compose File To use Docker-Compose, we need to make a docker-compose.yaml file. In this file, we will define three different containers as services and then connect them with each other. Then we can use a single command to run our containers together. These services are:\n the Django app container, the database container and the Nginx webserver container.  We will add each of these services to the docker-compose.yaml file one by one, starting with the web app. Make a new docker-compose.yaml file in the deployment-project directory with the following contents:\nversion: '3' services: web: container_name: django build: djangoproject/ command: python manage.py runserver 0.0.0.0:8000 ports: - 8000:8000 Above, we defined a service for the web app. Let’s it breakdown and see what each option does:\n container_name defines the hostname of the container. This can be used by other containers to refer to this container. build takes the path of the Dockerfile directory. command takes a command you can run in the container after start up. In this case, we run the Django server on all available interfaces at port 8000. ports takes a list of ports to bind to the ports of your host machine. Above, we bind the port 8000 of the container to the port 8000 of your host. This means that you can access the Django app at localhost:8000 of your machine.  Let’s test if everything works until now. Run the following command.\n$ docker-compose up --build You should see the Django app running inside the container. The --build flag is used to tell Docker to build the container.\nStep 3 — Setting Up The Database Let’s set up the database now. We will be using a PostgreSQL database for our app. To set this up, we will have to complete the following steps:\n Add a database service to the docker-compose file. Define environment variables for the PostgreSQL database. Configure our Django app to use the database we just created. This includes connecting to the database, making migrations and migrating.  Change the docker-compose.yaml file to look like the following:\nversion: '3' services: db: container_name: postgresdb image: postgres:latest restart: always env_file: - project.env ports: - 5432:5432 volumes: - postgres-data:/var/lib/postgresql/data web: container_name: django build: djangoproject/ command: python manage.py runserver 0.0.0.0:8000 env_file: - project.env ports: - 8000:8000 depends_on: - db volumes: postgres-data: Again, a breakdown of the changes:\n image tells docker which image to use. In this case, we tell it to pull whichever image is associated with the latest tag for postgres. restart: always makes sure the database always restarts when it exits. Other options for this are no, on-failure and unless-stopped env_file is used to put the environment variables in a file and tell Docker to initialize the container with those variables. We will create this file soon. volumes is used for data persistency. It would be a shame if our database was empty every time we started it and destroyed its data everytime we turned it off. Docker uses volumes to store data that must be persistent on disk. Above, we define a new volume and tell docker to save the contents of /var/lib/postgresql/data inside that volume. Note that we have to define volumes in the volumes section in the bottom. depends_on tells Docker that the web service depends on the db service.  Now, lets create the project.env file we mentioned above. Make a new file called project.env in the deployment-project directory with the following contents. We’ll add more to this file later.\nPOSTGRES_USER=userone POSTGRES_PASSWORD=secretpassword POSTGRES_DB=project_db DATABASE=postgres DATABASE_HOST=postgresdb DATABASE_PORT=5432 Next, we will configure the Django app to connect to the database. To connect to the database, Django needs to have a driver installed. For PostgreSQL, that driver is psycopg2.\n$ pip install psycopg2-binary You should install psycopg2-binary instead of psycopg2 if you want to install psycopg2 without install PostgreSQL on your system. Now, update the requirements.txt file\n$ pip freeze  djangoproject/requirements.txt Now we will configure the Django settings. First, make a new file called keyconfig.py in the djangoproject/djangoproject directory. We will save credentials and other sensitive information here. The purpose of using a keyconfig instead of directly loading environment variables in settings.py is that you can separate parts of your config using classes. Add the following contents to the keyconfig.py file:\nimport os class Database: NAME = os.getenv('POSTGRES_DB') USER = os.getenv('POSTGRES_USER') PASSWORD = os.getenv('POSTGRES_PASSWORD') HOST = os.getenv('DATABASE_HOST') PORT = os.getenv('DATABASE_PORT') class Secrets: SECRET_KEY = \"SuperSecretSecretKey\" Open djangoproject/djangoproject/settings.py and import the keyconfig.py file like this:\n... from djangoproject.keyconfig import Database, Secrets settings.py Now, set the Secret key: SECRET_KEY = Secrets.SECRET_KEY settings.py And the database: DATABASES = { \"default\": { \"ENGINE\": \"django.db.backends.postgresql\", \"NAME\": Database.NAME, \"USER\": Database.USER, \"PASSWORD\": Database.PASSWORD, \"HOST\": Database.HOST, \"PORT\": Database.PORT, } } Now, we want to makemigrations and migrate everytime the container starts up. But the problem is that the database container can take longer to initialise and if we run the above commands before the database is up and running, it can result in an error. So we need a way to make sure the database has started. For this, we use an entrypoint script. In the djangoproject directory, make a new file called entrypoint.sh with the following contents.\n#!/bin/sh  if [ \"$DATABASE\" = \"postgres\" ]; then echo \"Waiting for postgres...\" while ! nc -z $DATABASE_HOST $DATABASE_PORT; do sleep 0.1 done echo \"PostgreSQL started\" fi # Make migrations and migrate the database. echo \"Making migrations and migrating the database. \" python manage.py makemigrations main --noinput python manage.py migrate --noinput exec \"$@\" The above script first waits for the database to start up. We do this by using netcat to ping the server in a while loop. Then it makes migrations and performs the migrations. The --noinput flag is used when we are using the command inside a script so that it does not prompt the user for input. Next, we need to make the file executable so that Docker can run it.\n$ sudo chmod +x entrypoint.sh Now change the Dockerfile to use this script. Add the following lines at the end of the Dockerfile:\nRUN apt-get update \u0026\u0026 apt-get install -y netcat ENTRYPOINT [\"/code/entrypoint.sh\"]We need to install netcat as it is not installed by default. Once again, let’s test if everything is running. Go to the deployment-project directory and spin up the containers.\n$ docker-compose up --build -d You can use the -d flag to make the containers run in the background.\nStep 4 — Using Nginx to Serve the Django app In this step, we will set up another container to use Nginx to serve our django project. For this, we will do the following:\n Install and use gunicorn as our WSGI server Configure nginx as a reverse proxy for the gunicorn server. Add an nginx service to the docker-compose file.  Gunicorn is a production level WSGI server we will use to serve our Django project. To begin let’s, install gunicorn.\n$ pip install gunicorn To use gunicorn as our WSGI server, we use the following command:\n$ gunicorn djangoproject.wsgi:application --bind 0.0.0.0:8000 --workers=4 In the above command, djangoproject.wsgi is the name of the WSGI module to use. The --bind takes address of the socker to bind to. In this case, we tell it to bind to port 8000 of all available interfaces. The --workers flag takes the number of workers to be initialized by gunicorn, we set it to 4 here.\nOnce again, update the requirements.txt file.\n$ pip freeze  djangoproject/requirements.txt Next, let’s make a configuration file for the nginx server.\nInside the deployment-project directory, make a directory called nginx.\n$ mkdir nginx \u0026\u0026 cd nginx $ touch nginx.conf Open the nginx.conf file and add the following:\nupstream djangoapp { server django:8000; } server { listen 80; listen [::]:80; location / { proxy_pass http://djangoapp; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_redirect off; } } Next, we add the nginx service to the docker-compose file and also use gunicorn for the Django app. Open the docker-compose.yaml file and change it to the following:\nversion: '3' services: db: container_name: postgresdb image: postgres:latest restart: always env_file: - project.env ports: - 5432:5432 volumes: - postgres-data:/var/lib/postgresql/data web: container_name: django build: djangoproject/ command:  gunicorn djangoproject.wsgi:application --bind 0.0.0.0:8000 --workers=4 env_file: - project.env expose: - 8000 depends_on: - db nginx: container_name: nginx image: nginx:mainline-alpine restart: always ports: - 1337:80 volumes: - ./nginx:/etc/nginx/conf.d depends_on: - web volumes: postgres-data:  In the volumes section in nginx, we mount the local ./nginx directory to the /etc/nginx/conf.d directory in the container. In depends_on, we say that the nginx service depends on the web service. Instead of using ports in the web service, we use expose to expose the port 8000 of the container to other containers on the network. But, in the nginx service, we use ports to bind the port 80 of the container to the port 1337 of the host machine.   The difference between ports and expose _ Use ports when you want to access the port from the host machine’s localhost. Use expose when you want to expose the port to other containers in the network. _\n Again, test that everything is working by spinning up the containers.\n$ docker-compose up --build Test that you can see the webserver by going to localhost:1337 in your webbrowser.\nStep 5 — The Dockerfile, Revisited Before configuring the staticfiles, we will take another look at the Dockerfile and restructure it. Previously, we were running the processes inside the Django container as a root user. But, according to the Docker documentation, the best practice is to run your processes as non-privileged user within the containers. So, in this step, we will restructure the Dockerfile and also make a new user to run our app inside the container.\nMake a new Dockerfile with the following contents.\nFROMpython:3.8.2ENV PYTHONBUFFERED 1ENV PYTHONWRITEBYTECODE 1RUN apt-get update \\  \u0026\u0026 apt-get install -y netcat# Create an app user in the app group. RUN useradd --user-group --create-home --no-log-init --shell /bin/bash appENV APP_HOME=/home/app/web# Create the staticfiles directory. This avoids permission errors. RUN mkdir -p $APP_HOME/staticfiles# Change the workdir.WORKDIR$APP_HOMECOPY requirements.txt $APP_HOMERUN pip install --upgrade pipRUN pip install -r requirements.txtCopy the code and make the app user the owner of the directory.\nCOPY . $APP_HOMERUN chown -R app:app $APP_HOMEChange the user to app and run the entrypoint.\nUSERapp:appENTRYPOINT [\"/home/app/web/entrypoint.sh\"]Test that everything works by spinning up the containers.\n$ docker-compose up --build -d Verify that the server is running by going to localhost:1337 in your browser.\nStep 6 — Serving Static Files with Nginx We need to configure nginx to serve our staticfiles because Django does not serve staticfiles in production. First, we configure Django to use a staticfiles directory. Open settings.py and add the following in the staticfiles section:\nSTATIC_URL = \"/static/\" STATIC_ROOT = os.path.join(BASE_DIR, \"staticfiles\") We tell Django that the staticfiles are going to be served at the /static/ path. And that the files are going to be in the staticfiles directory.\nNext, open the nginx.conf file and add the following:\nserver { ... location /static/ { alias /home/app/web/staticfiles/; } } We tell Nginx to serve the contents of the staticfiles directory at the /static/ path.\nNext, we need to edit the entrypoint script to collect the static files. Add the following at the end of the entrypoint.sh file.\n#!/bin/sh ... python manage.py collectstatic --noinput exec \"$@\" To let Nginx access the staticfiles collected by Django, we will store them in a volume and add this volume to both the web and nginx services.\nweb: container_name: django build: djangoproject/ command:  gunicorn djangoproject.wsgi:application --bind 0.0.0.0:8000 --workers=4 env_file: - project.env expose: - 8000 depends_on: - db volumes: - staticfiles:/home/app/web/staticfiles nginx: container_name: nginx image: nginx:mainline-alpine restart: always ports: - 80:1337 volumes: - ./nginx:/etc/nginx/conf.d - staticfiles:/home/app/web/staticfiles depends_on: - web And add this volume to the volumes section:\nvolumes: postgres-data: staticfiles: Check that the staticfiles have loaded by spinning up the containers and going to the admin page at localhost:1337/admin/ you should see the CSS loaded.\nConclusion If you reached until here, you will have a ready to deploy Django app which will be up and running in just one command. You can use this configuration for your own Django apps and deploy them to a server with only a few extra steps.\nThe full code for this guide is available on Github here.\n","wordCount":"2656","inLanguage":"en","datePublished":"2020-04-30T10:29:26Z","dateModified":"2020-04-30T10:29:26Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hedonhermdev.github.io/posts/django-on-docker/"},"publisher":{"@type":"Organization","name":"HedonHermDev","logo":{"@type":"ImageObject","url":"https://hedonhermdev.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://hedonhermdev.github.io accesskey=h>HedonHermDev</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://hedonhermdev.github.io/><span>~</span></a></li><li><a href=https://hedonhermdev.github.io/about/><span>~/about</span></a></li><li><a href=https://hedonhermdev.github.io/posts/><span>~/posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>How To Deploy Your Django App Using Docker</h1><div class=post-meta>April 30, 2020&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary><div class=details accesskey=c>Table of Contents</div></summary><blockquote><ul><li><a href=#heres-what-youll-learn aria-label="Here&amp;rsquo;s what you&amp;rsquo;ll learn">Here&rsquo;s what you&rsquo;ll learn</a></li><li><a href=#the-prerequisites aria-label="The prerequisites">The prerequisites</a></li><li><a href=#step-0--installing-dependencies aria-label="Step 0 — Installing Dependencies">Step 0 — Installing Dependencies</a><ul><li><a href=#installing-on-ubuntu aria-label="Installing on Ubuntu">Installing on Ubuntu</a></li><li><a href=#installing-on-a-mac aria-label="Installing on a Mac">Installing on a Mac</a></li></ul></li><li><a href=#step-1--setting-up-the-django-project aria-label="Step 1 — Setting Up The Django Project">Step 1 — Setting Up The Django Project</a></li><li><a href=#step-1--writing-the-dockerfile aria-label="Step 1 — Writing The Dockerfile">Step 1 — Writing The Dockerfile</a></li><li><a href=#step-2--writing-the-docker-compose-file aria-label="Step 2 — Writing the Docker-Compose File">Step 2 — Writing the Docker-Compose File</a></li><li><a href=#step-3--setting-up-the-database aria-label="Step 3 — Setting Up The Database">Step 3 — Setting Up The Database</a></li><li><a href=#step-4--using-nginx-to-serve-the-django-app aria-label="Step 4 — Using Nginx to Serve the Django app">Step 4 — Using Nginx to Serve the Django app</a></li><li><a href=#step-5--the-dockerfile-revisited aria-label="Step 5 — The Dockerfile, Revisited">Step 5 — The Dockerfile, Revisited</a></li><li><a href=#step-6--serving-static-files-with-nginx aria-label="Step 6 — Serving Static Files with Nginx">Step 6 — Serving Static Files with Nginx</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></blockquote></details></div><div class=post-content><p>Getting your Django app on the internet is - pardon my language - a pain in the ass.</p><p>You need to daemonize your app with something like Supervisor, then you need to setup a production ready database, then you need to setup a web-server using the likes of Nginx or Apache. And when it&rsquo;s all done, you need to setup files and directories to collect and maintain logs from your app.</p><p>You could do all that, or you could use Docker.</p><h2 id=heres-what-youll-learn>Here&rsquo;s what you&rsquo;ll learn<a hidden class=anchor aria-hidden=true href=#heres-what-youll-learn>#</a></h2><p>In this tutorial you&rsquo;ll learn to deploy a Django app with Docker and docker-compose. By the end of the tutorial, you&rsquo;ll have a single command that you can use with *any *Django app to deploy it to a server.</p><h2 id=the-prerequisites>The prerequisites<a hidden class=anchor aria-hidden=true href=#the-prerequisites>#</a></h2><p>To complete this tutorial, you will need:</p><ul><li>Familiarity with using the command line.</li><li>Familiarity with Python virtual environments. We will use a virtual environment to isolate the dependencies of our project. To install the python virtual environment module use: <code>pip install virtualenv</code>.</li><li>A basic understanding of YAML files.</li></ul><h2 id=step-0--installing-dependencies>Step 0 — Installing Dependencies<a hidden class=anchor aria-hidden=true href=#step-0--installing-dependencies>#</a></h2><p>To follow this tutorial, you will need both Docker and Docker-Compose on your machine. Follow the steps below depending on your operating system.</p><h3 id=installing-on-ubuntu>Installing on Ubuntu<a hidden class=anchor aria-hidden=true href=#installing-on-ubuntu>#</a></h3><p>You can install Docker Engine on your system by using the convenience script provided by Docker.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ curl -fsSL https://get.docker.com -o get-docker.sh
$ sudo sh get-docker.sh
</code></pre></div><p>To install Docker-Compose, first download the binaries from the Github repo. Then apply executable permissions to the binary.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ sudo curl -L <span style=color:#e6db74>&#34;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-</span><span style=color:#66d9ef>$(</span>uname -s<span style=color:#66d9ef>)</span><span style=color:#e6db74>-</span><span style=color:#66d9ef>$(</span>uname -m<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> -o /usr/local/bin/docker-compose

$ sudo chmod +x /usr/local/bin/docker-compose
</code></pre></div><h3 id=installing-on-a-mac>Installing on a Mac<a hidden class=anchor aria-hidden=true href=#installing-on-a-mac>#</a></h3><p>Docker Desktop for Mac already includes Docker-Compose. To install Docker Desktop on Mac, download the package from <a href=https://hub.docker.com/editions/community/docker-ce-desktop-mac/>here</a> and run the installer.</p><p>Note: If the above steps don&rsquo;t work for you, you can go to this <a href=https://docs.docker.com/get-docker/>link</a> and find more information depending on your operating system.</p><h2 id=step-1--setting-up-the-django-project>Step 1 — Setting Up The Django Project<a hidden class=anchor aria-hidden=true href=#step-1--setting-up-the-django-project>#</a></h2><p>For following along, you can make a sample Django project or follow the steps with your existing project. I suggest making a sample app and then implementing it on your existing project so that you can tweak things to suit your purpose.</p><p>Create a new virtual environment.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ mkdir deployment-project <span style=color:#f92672>&amp;&amp;</span> cd deployment-project
$ virtualenv venv
$ source venv/bin/activate
</code></pre></div><p>Install Django and make a new Django project.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ pip install django
$ django-admin startproject djangoproject
</code></pre></div><p>List out the requirements in a <code>requirements.txt</code> file.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ pip freeze &gt; djangoproject/requirements.txt
</code></pre></div><p>In the <code>djangoproject/settings.py</code> file, change the <code>ALLOWED_HOSTS</code> to the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>ALLOWED_HOSTS <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;localhost&#34;</span>, <span style=color:#e6db74>&#34;127.0.0.1&#34;</span>, <span style=color:#e6db74>&#34;0.0.0.0&#34;</span>]
</code></pre></div><p>Doing this allows us to access the Django app from outside the container.</p><h2 id=step-1--writing-the-dockerfile>Step 1 — Writing The Dockerfile<a hidden class=anchor aria-hidden=true href=#step-1--writing-the-dockerfile>#</a></h2><p>The first step to containerising our Django app is making a Dockerfile. In the <code>djangoproject</code> directory, make a new file named <code>Dockerfile</code> and put the following in it:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=color:#75715e># Use the official Python image from the Docker Hub</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> python:3.8.2</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># These two environment variables prevent __pycache__/ files.</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> PYTHONUNBUFFERED <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> PYTHONDONTWRITEBYTECODE <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Make a new directory to put our code in.</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> mkdir /code<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Change the working directory. </span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Every command after this will be run from the /code directory.</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /code</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Copy the requirements.txt file.</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> ./requirements.txt /code/<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Upgrade pip</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> pip install --upgrade pip<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Install the requirements.</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> pip install -r requirements.txt<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Copy the rest of the code. </span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> . /code/<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>This Dockerfile is used to build the container for your Django app. Each line is a step of the build. We will make a lot of changes in this, but for now, it works.</p><blockquote><p><strong>Why you should copy the requirements.txt file before copying the code</strong>
<em>While building the container, Docker caches stages of the build. So if you change your code but the <code>requirements.txt</code> file is the same, Docker doesn&rsquo;t have to install all the requirements again for building the container.</em></p></blockquote><h2 id=step-2--writing-the-docker-compose-file>Step 2 — Writing the Docker-Compose File<a hidden class=anchor aria-hidden=true href=#step-2--writing-the-docker-compose-file>#</a></h2><p>To use Docker-Compose, we need to make a <code>docker-compose.yaml</code> file. In this file, we will define three different containers as services and then connect them with each other. Then we can use a single command to run our containers together. These services are:</p><ul><li>the Django app container,</li><li>the database container and</li><li>the Nginx webserver container.</li></ul><p>We will add each of these services to the <code>docker-compose.yaml</code> file one by one, starting with the web app. Make a new <code>docker-compose.yaml</code> file in the <code>deployment-project</code> directory with the following contents:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#39;3&#39;</span>

<span style=color:#f92672>services</span>:
  <span style=color:#f92672>web</span>:
    <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>django</span>
    <span style=color:#f92672>build</span>: <span style=color:#ae81ff>djangoproject/</span>
    <span style=color:#f92672>command</span>: <span style=color:#ae81ff>python manage.py runserver 0.0.0.0:8000</span>
    <span style=color:#f92672>ports</span>:
      - <span style=color:#ae81ff>8000</span>:<span style=color:#ae81ff>8000</span>
</code></pre></div><p>Above, we defined a service for the web app. Let&rsquo;s it breakdown and see what each option does:</p><ul><li><code>container_name</code> defines the hostname of the container. This can be used by other containers to refer to this container.</li><li><code>build</code> takes the path of the Dockerfile directory.</li><li><code>command</code> takes a command you can run in the container after start up. In this case, we run the Django server on all available interfaces at port <code>8000</code>.</li><li><code>ports</code> takes a list of ports to bind to the ports of your host machine. Above, we bind the port <code>8000</code> of the container to the port <code>8000</code> of your host. This means that you can access the Django app at <code>localhost:8000</code> of your machine.</li></ul><p>Let&rsquo;s test if everything works until now. Run the following command.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ docker-compose up --build
</code></pre></div><p>You should see the Django app running inside the container. The <code>--build</code> flag is used to tell Docker to build the container.</p><h2 id=step-3--setting-up-the-database>Step 3 — Setting Up The Database<a hidden class=anchor aria-hidden=true href=#step-3--setting-up-the-database>#</a></h2><p>Let&rsquo;s set up the database now. We will be using a PostgreSQL database for our app. To set this up, we will have to complete the following steps:</p><ul><li>Add a database service to the docker-compose file.</li><li>Define environment variables for the PostgreSQL database.</li><li>Configure our Django app to use the database we just created. This includes connecting to the database, making migrations and migrating.</li></ul><p>Change the <code>docker-compose.yaml</code> file to look like the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#39;3&#39;</span>

<span style=color:#f92672>services</span>:
  <span style=color:#f92672>db</span>:
    <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>postgresdb</span>
    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>postgres:latest</span>
    <span style=color:#f92672>restart</span>: <span style=color:#ae81ff>always</span>
    <span style=color:#f92672>env_file</span>:
      - <span style=color:#ae81ff>project.env</span>
    <span style=color:#f92672>ports</span>:
      - <span style=color:#ae81ff>5432</span>:<span style=color:#ae81ff>5432</span>
    <span style=color:#f92672>volumes</span>:
      - <span style=color:#ae81ff>postgres-data:/var/lib/postgresql/data</span>

  <span style=color:#f92672>web</span>:
    <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>django</span>
    <span style=color:#f92672>build</span>: <span style=color:#ae81ff>djangoproject/</span>
    <span style=color:#f92672>command</span>: <span style=color:#ae81ff>python manage.py runserver 0.0.0.0:8000</span>
    <span style=color:#f92672>env_file</span>:
      - <span style=color:#ae81ff>project.env</span>
    <span style=color:#f92672>ports</span>:
      - <span style=color:#ae81ff>8000</span>:<span style=color:#ae81ff>8000</span>
    <span style=color:#f92672>depends_on</span>:
      - <span style=color:#ae81ff>db</span>
<span style=color:#f92672>volumes</span>:
  <span style=color:#f92672>postgres-data</span>:
</code></pre></div><p>Again, a breakdown of the changes:</p><ul><li><code>image</code> tells docker which image to use. In this case, we tell it to pull whichever image is associated with the <code>latest</code> tag for postgres.</li><li><code>restart: always</code> makes sure the database always restarts when it exits. Other options for this are <code>no</code>, <code>on-failure</code> and <code>unless-stopped</code></li><li><code>env_file</code> is used to put the environment variables in a file and tell Docker to initialize the container with those variables. We will create this file soon.</li><li><code>volumes</code> is used for data persistency. It would be a shame if our database was empty every time we started it and destroyed its data everytime we turned it off. Docker uses volumes to store data that must be persistent on disk. Above, we define a new volume and tell docker to save the contents of <code>/var/lib/postgresql/data</code> inside that volume. Note that we have to define volumes in the <code>volumes</code> section in the bottom.</li><li><code>depends_on</code> tells Docker that the web service depends on the db service.</li></ul><p>Now, lets create the <code>project.env</code> file we mentioned above. Make a new file called <code>project.env</code> in the <code>deployment-project</code> directory with the following contents. We&rsquo;ll add more to this file later.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-env data-lang=env>POSTGRES_USER<span style=color:#f92672>=</span>userone
POSTGRES_PASSWORD<span style=color:#f92672>=</span>secretpassword
POSTGRES_DB<span style=color:#f92672>=</span>project_db

DATABASE<span style=color:#f92672>=</span>postgres
DATABASE_HOST<span style=color:#f92672>=</span>postgresdb
DATABASE_PORT<span style=color:#f92672>=</span><span style=color:#ae81ff>5432</span>
</code></pre></div><p>Next, we will configure the Django app to connect to the database. To connect to the database, Django needs to have a driver installed. For PostgreSQL, that driver is <code>psycopg2</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ pip install psycopg2-binary
</code></pre></div><p>You should install <code>psycopg2-binary</code> instead of <code>psycopg2</code> if you want to install psycopg2 without install PostgreSQL on your system. Now, update the <code>requirements.txt</code>  file</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ pip freeze &gt; djangoproject/requirements.txt
</code></pre></div><p>Now we will configure the Django settings. First, make a new file called <code>keyconfig.py</code> in the <code>djangoproject/djangoproject</code> directory. We will save credentials and other sensitive information here. The purpose of using a keyconfig instead of directly loading environment variables in <code>settings.py</code> is that you can separate parts of your config using classes. Add the following contents to the <code>keyconfig.py</code> file:</p><pre><code>import os

class Database:
    NAME = os.getenv('POSTGRES_DB')
    USER = os.getenv('POSTGRES_USER')
    PASSWORD = os.getenv('POSTGRES_PASSWORD')
    HOST = os.getenv('DATABASE_HOST')
    PORT = os.getenv('DATABASE_PORT')


class Secrets:
    SECRET_KEY = &quot;SuperSecretSecretKey&quot;
</code></pre><p>Open <code>djangoproject/djangoproject/settings.py</code> and import the <code>keyconfig.py</code> file like this:</p><pre><code>...

from djangoproject.keyconfig import Database, Secrets

settings.py
Now, set the Secret key:

SECRET_KEY = Secrets.SECRET_KEY

settings.py
And the database:

DATABASES = {
    &quot;default&quot;: {
        &quot;ENGINE&quot;: &quot;django.db.backends.postgresql&quot;,
        &quot;NAME&quot;: Database.NAME,
        &quot;USER&quot;: Database.USER,
        &quot;PASSWORD&quot;: Database.PASSWORD,
        &quot;HOST&quot;: Database.HOST,
        &quot;PORT&quot;: Database.PORT,
    }
}

</code></pre><p>Now, we want to <code>makemigrations</code> and <code>migrate</code> everytime the container starts up. But the problem is that the database container can take longer to initialise and if we run the above commands before the database is up and running, it can result in an error. So we need a way to make sure the database has started. For this, we use an entrypoint script. In the <code>djangoproject</code> directory, make a new file called <code>entrypoint.sh</code> with the following contents.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e>#!/bin/sh
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span>$DATABASE<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;postgres&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;Waiting for postgres...&#34;</span>

    <span style=color:#66d9ef>while</span> ! nc -z $DATABASE_HOST $DATABASE_PORT; <span style=color:#66d9ef>do</span>
      sleep 0.1
    <span style=color:#66d9ef>done</span>

    echo <span style=color:#e6db74>&#34;PostgreSQL started&#34;</span>
<span style=color:#66d9ef>fi</span>

<span style=color:#75715e># Make migrations and migrate the database.</span>
echo <span style=color:#e6db74>&#34;Making migrations and migrating the database. &#34;</span>
python manage.py makemigrations main --noinput 
python manage.py migrate --noinput 

exec <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>The above script first waits for the database to start up. We do this by using <code>netcat</code> to ping the server in a while loop. Then it makes migrations and performs the migrations. The <code>--noinput</code> flag is used when we are using the command inside a script so that it does not prompt the user for input. Next, we need to make the file executable so that Docker can run it.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ sudo chmod +x entrypoint.sh
</code></pre></div><p>Now change the Dockerfile to use this script. Add the following lines at the end of the Dockerfile:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=color:#66d9ef>RUN</span> apt-get update <span style=color:#f92672>&amp;&amp;</span> apt-get install -y netcat<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span> <span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;/code/entrypoint.sh&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>We need to install netcat as it is not installed by default. Once again, let&rsquo;s test if everything is running. Go to the <code>deployment-project</code> directory and spin up the containers.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ docker-compose up --build -d
</code></pre></div><p>You can use the <code>-d</code> flag to make the containers run in the background.</p><h2 id=step-4--using-nginx-to-serve-the-django-app>Step 4 — Using Nginx to Serve the Django app<a hidden class=anchor aria-hidden=true href=#step-4--using-nginx-to-serve-the-django-app>#</a></h2><p>In this step, we will set up another container to use Nginx to serve our django project. For this, we will do the following:</p><ul><li>Install and use gunicorn as our WSGI server</li><li>Configure nginx as a reverse proxy for the gunicorn server.</li><li>Add an nginx service to the docker-compose file.</li></ul><p>Gunicorn is a production level WSGI server we will use to serve our Django project. To begin let&rsquo;s, install gunicorn.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ pip install gunicorn
</code></pre></div><p>To use gunicorn as our WSGI server, we use the following command:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ gunicorn djangoproject.wsgi:application --bind 0.0.0.0:8000 --workers<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>
</code></pre></div><p>In the above command, <code>djangoproject.wsgi</code> is the name of the WSGI module to use. The  <code>--bind</code> takes address of the socker to bind to. In this case, we tell it to bind to port <code>8000</code> of all available interfaces. The <code>--workers</code> flag takes the number of workers to be initialized by gunicorn, we set it to 4 here.</p><p>Once again, update the <code>requirements.txt</code> file.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ pip freeze &gt; djangoproject/requirements.txt
</code></pre></div><p>Next, let&rsquo;s make a configuration file for the <code>nginx</code> server.</p><p>Inside the <code>deployment-project</code> directory, make a directory called <code>nginx</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ mkdir nginx <span style=color:#f92672>&amp;&amp;</span> cd nginx
$ touch nginx.conf
</code></pre></div><p>Open the <code>nginx.conf</code> file and add the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=color:#66d9ef>upstream</span> <span style=color:#e6db74>djangoapp</span> {
    <span style=color:#f92672>server</span> django:<span style=color:#ae81ff>8000</span>;
}

<span style=color:#66d9ef>server</span> {
    <span style=color:#f92672>listen</span> <span style=color:#ae81ff>80</span>;
    <span style=color:#f92672>listen</span> <span style=color:#e6db74>[::]:80</span>;
    
    <span style=color:#f92672>location</span> <span style=color:#e6db74>/</span> {
        <span style=color:#f92672>proxy_pass</span> <span style=color:#e6db74>http://djangoapp</span>;
        <span style=color:#f92672>proxy_set_header</span> <span style=color:#e6db74>X-Forwarded-For</span> $proxy_add_x_forwarded_for;
        <span style=color:#f92672>proxy_set_header</span> <span style=color:#e6db74>Host</span> $host;
        <span style=color:#f92672>proxy_redirect</span> <span style=color:#66d9ef>off</span>;
    }
}
</code></pre></div><p>Next, we add the <code>nginx</code> service to the docker-compose file and also use gunicorn for the Django app. Open the <code>docker-compose.yaml</code> file and change it to the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#39;3&#39;</span>

<span style=color:#f92672>services</span>:
  <span style=color:#f92672>db</span>:
    <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>postgresdb</span>
    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>postgres:latest</span>
    <span style=color:#f92672>restart</span>: <span style=color:#ae81ff>always</span>
    <span style=color:#f92672>env_file</span>:
      - <span style=color:#ae81ff>project.env</span>
    <span style=color:#f92672>ports</span>:
      - <span style=color:#ae81ff>5432</span>:<span style=color:#ae81ff>5432</span>
    <span style=color:#f92672>volumes</span>:
      - <span style=color:#ae81ff>postgres-data:/var/lib/postgresql/data</span>
  <span style=color:#f92672>web</span>:
    <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>django</span>
    <span style=color:#f92672>build</span>: <span style=color:#ae81ff>djangoproject/</span>
    <span style=color:#f92672>command</span>: &gt;<span style=color:#e6db74>
</span><span style=color:#e6db74>      </span>      <span style=color:#ae81ff>gunicorn djangoproject.wsgi:application --bind 0.0.0.0:8000 --workers=4</span>
    <span style=color:#f92672>env_file</span>:
      - <span style=color:#ae81ff>project.env</span>
    <span style=color:#f92672>expose</span>:
      - <span style=color:#ae81ff>8000</span>
    <span style=color:#f92672>depends_on</span>:
      - <span style=color:#ae81ff>db</span>
  <span style=color:#f92672>nginx</span>:
    <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>nginx</span>
    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:mainline-alpine</span>
    <span style=color:#f92672>restart</span>: <span style=color:#ae81ff>always</span>
    <span style=color:#f92672>ports</span>:
      - <span style=color:#ae81ff>1337</span>:<span style=color:#ae81ff>80</span>
    <span style=color:#f92672>volumes</span>:
      - <span style=color:#ae81ff>./nginx:/etc/nginx/conf.d</span>
    <span style=color:#f92672>depends_on</span>:
      - <span style=color:#ae81ff>web</span>

<span style=color:#f92672>volumes</span>:
  <span style=color:#f92672>postgres-data</span>:
</code></pre></div><ul><li>In the <code>volumes</code> section in nginx, we mount the local  <code>./nginx</code> directory to the <code>/etc/nginx/conf.d</code> directory in the container.</li><li>In <code>depends_on</code>, we say that the <code>nginx</code> service depends on the <code>web</code> service.</li><li>Instead of using <code>ports</code> in the web service, we use <code>expose</code> to expose the port <code>8000</code> of the container to other containers on the network. But, in the nginx service, we use <code>ports</code> to bind the port <code>80</code> of the container to the port <code>1337</code> of the host machine.</li></ul><blockquote><p><strong>The difference between ports and expose</strong>
_ Use ports when you want to access the port from the host machine&rsquo;s localhost. Use expose when you want to expose the port to other containers in the network. _</p></blockquote><p>Again, test that everything is working by spinning up the containers.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ docker-compose up --build
</code></pre></div><p>Test that you can see the webserver by going to <code>localhost:1337</code> in your webbrowser.</p><h2 id=step-5--the-dockerfile-revisited>Step 5 — The Dockerfile, Revisited<a hidden class=anchor aria-hidden=true href=#step-5--the-dockerfile-revisited>#</a></h2><p>Before configuring the staticfiles, we will take another look at the Dockerfile and restructure it. Previously, we were running the processes inside the Django container as a root user. But, according to the Docker documentation, the best practice is to run your processes as non-privileged user within the containers. So, in this step, we will restructure the Dockerfile and also make a new user to run our app inside the container.</p><p>Make a new Dockerfile with the following contents.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> python:3.8.2</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> PYTHONBUFFERED <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> PYTHONWRITEBYTECODE <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apt-get update <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> apt-get install -y netcat<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Create an app user in the app group. </span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> useradd --user-group --create-home --no-log-init --shell /bin/bash app<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> APP_HOME<span style=color:#f92672>=</span>/home/app/web<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Create the staticfiles directory. This avoids permission errors. </span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> mkdir -p $APP_HOME/staticfiles<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Change the workdir.</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> $APP_HOME</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=color:#66d9ef>COPY</span> requirements.txt $APP_HOME<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> pip install --upgrade pip<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> pip install -r requirements.txt<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>Copy the code and make the app user the owner of the directory.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=color:#66d9ef>COPY</span> . $APP_HOME<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> chown -R app:app $APP_HOME<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>Change the user to <code>app</code> and run the entrypoint.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=color:#66d9ef>USER</span><span style=color:#e6db74> app:app</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;/home/app/web/entrypoint.sh&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>Test that everything works by spinning up the containers.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ docker-compose up --build -d
</code></pre></div><p>Verify that the server is running by going to <code>localhost:1337</code> in your browser.</p><h2 id=step-6--serving-static-files-with-nginx>Step 6 — Serving Static Files with Nginx<a hidden class=anchor aria-hidden=true href=#step-6--serving-static-files-with-nginx>#</a></h2><p>We need to configure nginx to serve our staticfiles because Django does not serve staticfiles in production. First, we configure Django to use a <code>staticfiles</code> directory. Open <code>settings.py</code> and add the following in the staticfiles section:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>STATIC_URL <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/static/&#34;</span>
STATIC_ROOT <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(BASE_DIR, <span style=color:#e6db74>&#34;staticfiles&#34;</span>)
</code></pre></div><p>We tell Django that the staticfiles are going to be served at the <code>/static/</code> path. And that the files are going to be in the <code>staticfiles</code> directory.</p><p>Next, open the <code>nginx.conf</code> file and add the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=color:#66d9ef>server</span> {
    <span style=color:#f92672>...</span>
    
    <span style=color:#e6db74>location</span> <span style=color:#e6db74>/static/</span> {
        <span style=color:#f92672>alias</span> <span style=color:#e6db74>/home/app/web/staticfiles/</span>;
    }
}
</code></pre></div><p>We tell Nginx to serve the contents of the <code>staticfiles</code> directory at the <code>/static/</code> path.</p><p>Next, we need to edit the entrypoint script to collect the static files. Add the following at the end of the <code>entrypoint.sh</code> file.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e>#!/bin/sh
</span><span style=color:#75715e></span>...

python manage.py collectstatic --noinput

exec <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span>
</code></pre></div><p>To let Nginx access the staticfiles collected by Django, we will store them in a volume and add this volume to both the <code>web</code> and <code>nginx</code> services.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>  <span style=color:#f92672>web</span>:
    <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>django</span>
    <span style=color:#f92672>build</span>: <span style=color:#ae81ff>djangoproject/</span>
    <span style=color:#f92672>command</span>: &gt;<span style=color:#e6db74>
</span><span style=color:#e6db74>      </span>      <span style=color:#ae81ff>gunicorn djangoproject.wsgi:application --bind 0.0.0.0:8000 --workers=4</span>
    <span style=color:#f92672>env_file</span>:
      - <span style=color:#ae81ff>project.env</span>
    <span style=color:#f92672>expose</span>:
      - <span style=color:#ae81ff>8000</span>
    <span style=color:#f92672>depends_on</span>:
      - <span style=color:#ae81ff>db</span>
    <span style=color:#f92672>volumes</span>:
      - <span style=color:#ae81ff>staticfiles:/home/app/web/staticfiles</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>  <span style=color:#f92672>nginx</span>:
    <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>nginx</span>
    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:mainline-alpine</span>
    <span style=color:#f92672>restart</span>: <span style=color:#ae81ff>always</span>
    <span style=color:#f92672>ports</span>:
      - <span style=color:#ae81ff>80</span>:<span style=color:#ae81ff>1337</span>
    <span style=color:#f92672>volumes</span>:
      - <span style=color:#ae81ff>./nginx:/etc/nginx/conf.d</span>
      - <span style=color:#ae81ff>staticfiles:/home/app/web/staticfiles</span>
    <span style=color:#f92672>depends_on</span>:
      - <span style=color:#ae81ff>web</span>
</code></pre></div><p>And add this volume to the volumes section:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>volumes</span>:
  <span style=color:#f92672>postgres-data</span>:
  <span style=color:#f92672>staticfiles</span>:
</code></pre></div><p>Check that the staticfiles have loaded by spinning up the containers and going to the admin page at <code>localhost:1337/admin/</code> you should see the CSS loaded.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>If you reached until here, you will have a ready to deploy Django app which will be up and running in just one command. You can use this configuration for your own Django apps and deploy them to a server with only a few extra steps.</p><p>The full code for this guide is available on Github <a href=https://github.com/hedonhermdev/django-on-docker>here</a>.</p></div><footer class=post-footer><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share How To Deploy Your Django App Using Docker on twitter" href="https://twitter.com/intent/tweet/?text=How%20To%20Deploy%20Your%20Django%20App%20Using%20Docker&url=https%3a%2f%2fhedonhermdev.github.io%2fposts%2fdjango-on-docker%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How To Deploy Your Django App Using Docker on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fhedonhermdev.github.io%2fposts%2fdjango-on-docker%2f&title=How%20To%20Deploy%20Your%20Django%20App%20Using%20Docker&summary=How%20To%20Deploy%20Your%20Django%20App%20Using%20Docker&source=https%3a%2f%2fhedonhermdev.github.io%2fposts%2fdjango-on-docker%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How To Deploy Your Django App Using Docker on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fhedonhermdev.github.io%2fposts%2fdjango-on-docker%2f&title=How%20To%20Deploy%20Your%20Django%20App%20Using%20Docker"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How To Deploy Your Django App Using Docker on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhedonhermdev.github.io%2fposts%2fdjango-on-docker%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How To Deploy Your Django App Using Docker on whatsapp" href="https://api.whatsapp.com/send?text=How%20To%20Deploy%20Your%20Django%20App%20Using%20Docker%20-%20https%3a%2f%2fhedonhermdev.github.io%2fposts%2fdjango-on-docker%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How To Deploy Your Django App Using Docker on telegram" href="https://telegram.me/share/url?text=How%20To%20Deploy%20Your%20Django%20App%20Using%20Docker&url=https%3a%2f%2fhedonhermdev.github.io%2fposts%2fdjango-on-docker%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2020 <a href=https://hedonhermdev.github.io>HedonHermDev</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top" accesskey=g><button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=https://hedonhermdev.github.io/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>